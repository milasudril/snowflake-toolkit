//@	{
//@	    "dependencies_extra":[],
//@	    "targets":[
//@	        {
//@	            "dependencies":[],
//@	            "name":"voxelbuilder_adda.o",
//@	            "type":"object"
//@	        }
//@	    ]
//@	}
#include "voxelbuilder_adda.h"
#include "volume_convex.h"
#include "file_out.h"
#include <cstring>

using namespace SnowflakeModel;

VoxelbuilderAdda::VoxelbuilderAdda(FileOut& dest
	,int n_x,int n_y,int n_z
	,const BoundingBox& bounding_box):
	r_dest(dest)
	,m_bounding_box(bounding_box)
	,m_n_x(n_x),m_n_y(n_y),m_n_z(n_z)
	{
	if(m_n_x<=0)
		{
		if(n_y > 0)
			{
			m_n_x=n_y*(bounding_box.m_max.x -  bounding_box.m_min.x)
				/(bounding_box.m_max.y -  bounding_box.m_min.y)+ 0.5;
			}
		else
		if(n_z > 0)
			{
			m_n_x=n_z*(bounding_box.m_max.x -  bounding_box.m_min.x)
				/(bounding_box.m_max.z -  bounding_box.m_min.z)+ 0.5;
			}
		else
			{throw "At leas one of Ny and Nz must be grater than zero";}
		}
	
	if(m_n_y<=0)
		{
		if(n_x > 0)
			{
			m_n_y=n_x*(bounding_box.m_max.y -  bounding_box.m_min.y)
				/(bounding_box.m_max.x -  bounding_box.m_min.x)+ 0.5;
			}
		else
		if(n_z > 0)
			{
			m_n_y=n_z*(bounding_box.m_max.y -  bounding_box.m_min.y)
				/(bounding_box.m_max.z -  bounding_box.m_min.z)+ 0.5;
			}
		else
			{throw "At leas one of Nx and Nz must be grater than zero";}
		}
	
	if(m_n_z<=0)
		{
		if(n_x > 0)
			{
			m_n_z=n_x*(bounding_box.m_max.z -  bounding_box.m_min.z)
				/(bounding_box.m_max.x -  bounding_box.m_min.x)+ 0.5;
			}
		else
		if(n_y > 0)
			{
			m_n_y=n_y*(bounding_box.m_max.z -  bounding_box.m_min.z)
				/(bounding_box.m_max.y -  bounding_box.m_min.y)+ 0.5;
			}
		else
			{throw "At leas one of Nx and Ny must be grater than zero";}
		}
	
	if(m_n_x==0 || m_n_y==0 || m_n_z==0)
		{throw "More points are needed to sample the generated geometry";}
	
	m_data_filled=new uint8_t[m_n_x*m_n_y*m_n_z];
	m_data_stop=new uint8_t[m_n_x*m_n_y*m_n_z];
	
	memset(m_data_filled,0,m_n_x*m_n_y*m_n_z);
	r_dest.printf("# ADDA geometry file generated by snowflake generator\n");
	r_dest.printf("# Bounding box is from (%.7g,%.7g,%.7g) to (%.7g,%.7g,%.7g)\n"
		,bounding_box.m_min.x,bounding_box.m_min.y,bounding_box.m_min.z
		,bounding_box.m_max.x,bounding_box.m_max.y,bounding_box.m_max.z);
	r_dest.printf("# Number of divisions is (%d,%d,%d)\n",m_n_x,m_n_y,m_n_z);
	}

VoxelbuilderAdda::~VoxelbuilderAdda()
	{
	delete[] m_data_filled;
	delete[] m_data_stop;
	}

PointInt VoxelbuilderAdda::quantize(const Point& p) const
	{
	auto range=m_bounding_box.m_max-m_bounding_box.m_min;
	auto pos=Vector(p)-m_bounding_box.m_min;
		
	return PointInt
		{
		 pos.x*m_n_x/range.x
		,pos.y*m_n_y/range.y
		,pos.z*m_n_z/range.z
		,1
		};
	}
	
Point VoxelbuilderAdda::dequantize(const PointInt& p) const
	{
	auto range=m_bounding_box.m_max-m_bounding_box.m_min;
	return Point
		{
		 m_bounding_box.m_min.x + (p.x+0.5)*range.x/m_n_x
		,m_bounding_box.m_min.y + (p.y+0.5)*range.y/m_n_y
		,m_bounding_box.m_min.z + (p.z+0.5)*range.z/m_n_z
		,1
		};
	}
	
void VoxelbuilderAdda::volumeStart(const VolumeConvex& volume_next)
	{
	r_volume_current=&volume_next;
	memset(m_data_stop,0,m_n_x*m_n_y*m_n_z);
	}
	
bool VoxelbuilderAdda::fill(const PointInt& pos)
	{
	if(pos.x>=0 && pos.y>=0 && pos.z>=0 
		&& pos.x<m_n_x && pos.y<m_n_y && pos.z<m_n_z)
		{
		auto offset=pos.x*m_n_y*m_n_z + pos.y*m_n_z + pos.z;
		if(m_data_stop[offset]==0)
			{
			if(r_volume_current->inside(dequantize(pos)))
				{
				m_data_stop[offset]=1;
				if(m_data_filled[offset]==0)
					{
					r_dest.printf("%d %d %d\n",pos.x,pos.y,pos.z);
					m_data_filled[offset]=1;
					}
				return 1;
				}
			}
		}
	return 0;
	}

